#Trabalho 1 - QuestÃ£o 3, letra d
using JuMP, GLPKMathProgInterface, Plots

#Declarando as variÃ¡veis
n = 10
T = 24
c = ones(Float64,n)
G = ones(Float64,n)
R_up = ones(Float64,n)
R_down = ones(Float64,n)
C_def = ones(Float64,2)
C_def[1] = 50
C_def[2] = 100
G_bat = 8
X = 1000
N = 1
d = ones(Float64,T*N)

for i=1:n
    c[i] = 2*i
    G[i] = 22 - 2*i
    R_up[i] = i
    R_down[i] = i
end

for N=1:4
        d = ones(Float64,T*N)
        h = N
        for t=1:T, h=1:N
            global d[t+(T*(h-1))] = 60*(1 + sin(t/12))
        end

        #Modelo sem a bateria

        desp_b = Model(solver = GLPKSolverLP())
        @variables(desp_b, begin
        g[i=1:n,t=1:T*N] >= 0
        def[j=1:2,t=1:T*N] >= 0
        end)
        @constraint(desp_b, [i=1:n, t=1:T*N], 0 <= g[i,t] <= G[i])
        @constraint(desp_b, [i=1:n, t=2:T*N], -R_down[i] <= g[i,t] - g[i,t-1] <= R_up[i])
        @constraint(desp_b, [t=1:T*N], sum(g[i,t] for i=1:n) + sum(def[j,t] for j=1:2) >= d[t])
        @constraint(desp_b, [t=1:T*N], 0 <= def[1,t] <= 0.05*d[t])
        @constraint(desp_b, [t=1:T*N], def[2,t] >= 0)
        @objective(desp_b, Min, sum(c[i]*g[i,t] for i=1:n, t=1:T*N) + sum(C_def[j]*def[j,t] for j=1:2, t=1:T*N))

        #Modelo com a bateria

        desp_c = Model(solver = GLPKSolverLP())
        @variables(desp_c, begin
            g[i=1:n,t=1:T*N] >= 0
            def[j=1:2,t=1:T*N] >= 0
            g_bat[t=1:T*N]
            B_bat[t=1:T*N] >=0
        end)
        @constraint(desp_c, [i=1:n, t=1:T*N], 0 <= g[i,t] <= G[i])
        @constraint(desp_c, [i=1:n, t=2:T*N], -R_down[i] <= g[i,t] - g[i,t-1] <= R_up[i])
        @constraint(desp_c, [t=1:T*N], sum(g[i,t] for i=1:n) + sum(def[j,t] for j=1:2) + g_bat[t] >= d[t])
        @constraint(desp_c, [t=1:T*N], 0 <= def[1,t] <= 0.05*d[t])
        @constraint(desp_c, [t=1:T*N], def[2,t] >= 0)
        @constraint(desp_c, [t=2:T*N], B_bat[t] == B_bat[t-1] - g_bat[t])
        @constraint(desp_c, [t=1:T*N], B_bat[t] <= G_bat)
        @constraint(desp_c, [t=1:T*N], g_bat[t] <= B_bat[t])
        @constraint(desp_c, B_bat[1] == G_bat - g_bat[1])

        @objective(desp_c, Min, sum(c[i]*g[i,t] for i=1:n, t=1:T*N) + sum(C_def[j]*def[j,t] for j=1:2, t=1:T*N) + X)

        global status_b = solve(desp_b)
        global f_b = getobjectivevalue(desp_b)/N
        global status_c = solve(desp_c)
        global f_c = getobjectivevalue(desp_c)/N
        global g_bateria = getvalue(g_bat)
        global geracao = getvalue(g)
        global deficit = getvalue(def[1,1:T*N]) + getvalue(def[2,1:T*N])
        global bateria = getvalue(B_bat)

        if f_b >= f_c
             println("N = ",N)
             break
        end
end
